-- -------------------------------------------------------------
-- 
-- File Name: C:\QPSK\hdl_prj_zcu111\hdlsrc\hdlcoder_QPSKTxRx_RFSoC\QPSK_src_Packet_Controller_block.vhd
-- Created: 2025-09-17 13:27:52
-- 
-- Generated by MATLAB 25.1, HDL Coder 25.1, and Simulink 25.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: QPSK_src_Packet_Controller_block
-- Source Path: hdlcoder_QPSKTxRx_RFSoC/QPSK/QPSK Tx/Bit Packetizer/Packet Controller
-- Hierarchy Level: 3
-- Model version: 9.4
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY QPSK_src_Packet_Controller_block IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        enable                            :   IN    std_logic;
        fifoNum                           :   IN    std_logic_vector(10 DOWNTO 0);  -- ufix11
        bitClk                            :   IN    std_logic;
        symbolClk                         :   IN    std_logic;
        dataStart                         :   OUT   std_logic;
        dataEnd                           :   OUT   std_logic;
        dataSel                           :   OUT   std_logic_vector(1 DOWNTO 0);  -- ufix2
        dataRd                            :   OUT   std_logic
        );
END QPSK_src_Packet_Controller_block;


ARCHITECTURE rtl OF QPSK_src_Packet_Controller_block IS

  -- Signals
  SIGNAL fifoNum_unsigned                 : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL dataSel_tmp                      : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL next_state                       : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL count_reg                        : unsigned(11 DOWNTO 0);  -- ufix12
  SIGNAL sel_reg                          : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL startNext_reg                    : std_logic;
  SIGNAL next_state_next                  : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL count_reg_next                   : unsigned(11 DOWNTO 0);  -- ufix12
  SIGNAL sel_reg_next                     : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL startNext_reg_next               : std_logic;

BEGIN
  fifoNum_unsigned <= unsigned(fifoNum);

  Packet_Controller_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        next_state <= to_unsigned(16#3#, 2);
        count_reg <= to_unsigned(16#000#, 12);
        sel_reg <= to_unsigned(16#0#, 2);
        startNext_reg <= '0';
      ELSIF enb = '1' THEN
        next_state <= next_state_next;
        count_reg <= count_reg_next;
        sel_reg <= sel_reg_next;
        startNext_reg <= startNext_reg_next;
      END IF;
    END IF;
  END PROCESS Packet_Controller_process;

  Packet_Controller_output : PROCESS (bitClk, count_reg, enable, fifoNum_unsigned, next_state, sel_reg,
       startNext_reg, symbolClk)
    VARIABLE dataPacketAvail : std_logic;
  BEGIN
    next_state_next <= next_state;
    count_reg_next <= count_reg;
    sel_reg_next <= sel_reg;
    startNext_reg_next <= startNext_reg;
    --MATLAB Function 'QPSK/QPSK Tx/Bit Packetizer/Packet Controller'
    -- Constants
    -- Initialize registers
    -- Signals
    -- signals from registers
    -- flags
    IF fifoNum_unsigned >= to_unsigned(16#046#, 11) THEN 
      dataPacketAvail := '1';
    ELSE 
      dataPacketAvail := '0';
    END IF;
    -- State machine logic
    -- defaults
    dataRd <= '0';
    dataStart <= '0';
    dataEnd <= '0';
    CASE next_state IS
      WHEN "11" =>
        IF (symbolClk AND enable) = '1' THEN 
          IF dataPacketAvail = '1' THEN 
            next_state_next <= to_unsigned(16#1#, 2);
            sel_reg_next <= to_unsigned(16#1#, 2);
          ELSE 
            next_state_next <= to_unsigned(16#0#, 2);
            sel_reg_next <= to_unsigned(16#0#, 2);
          END IF;
        END IF;
      WHEN "00" =>
        IF symbolClk = '1' THEN 
          IF ( NOT enable) = '1' THEN 
            next_state_next <= to_unsigned(16#3#, 2);
          ELSIF dataPacketAvail = '1' THEN 
            next_state_next <= to_unsigned(16#1#, 2);
            sel_reg_next <= to_unsigned(16#1#, 2);
            count_reg_next <= to_unsigned(16#000#, 12);
          END IF;
        END IF;
        IF bitClk = '1' THEN 
          dataRd <= '1';
        END IF;
      WHEN "01" =>
        IF bitClk = '1' THEN 
          count_reg_next <= count_reg + to_unsigned(16#001#, 12);
          IF count_reg = to_unsigned(16#019#, 12) THEN 
            next_state_next <= to_unsigned(16#2#, 2);
            sel_reg_next <= to_unsigned(16#2#, 2);
            startNext_reg_next <= '1';
            count_reg_next <= to_unsigned(16#000#, 12);
          END IF;
          dataRd <= '1';
        END IF;
      WHEN "10" =>
        IF bitClk = '1' THEN 
          IF count_reg = to_unsigned(16#8BF#, 12) THEN 
            IF ( NOT enable) = '1' THEN 
              next_state_next <= to_unsigned(16#3#, 2);
              sel_reg_next <= to_unsigned(16#0#, 2);
            ELSIF dataPacketAvail = '1' THEN 
              next_state_next <= to_unsigned(16#1#, 2);
              sel_reg_next <= to_unsigned(16#1#, 2);
            ELSE 
              next_state_next <= to_unsigned(16#0#, 2);
              sel_reg_next <= to_unsigned(16#0#, 2);
            END IF;
            count_reg_next <= to_unsigned(16#000#, 12);
            dataEnd <= '1';
          ELSE 
            count_reg_next <= count_reg + to_unsigned(16#001#, 12);
          END IF;
          dataRd <= '1';
          IF startNext_reg = '1' THEN 
            dataStart <= '1';
            startNext_reg_next <= '0';
          END IF;
        END IF;
      WHEN OTHERS => 
        NULL;
    END CASE;
    dataSel_tmp <= sel_reg;
  END PROCESS Packet_Controller_output;


  dataSel <= std_logic_vector(dataSel_tmp);

END rtl;

