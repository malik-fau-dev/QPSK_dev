-- -------------------------------------------------------------
-- 
-- File Name: C:\QPSK\hdl_prj_zcu111\hdlsrc\hdlcoder_QPSKTxRx_RFSoC\QPSK_src_sample_discard_controller.vhd
-- Created: 2025-09-17 13:27:52
-- 
-- Generated by MATLAB 25.1, HDL Coder 25.1, and Simulink 25.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: QPSK_src_sample_discard_controller
-- Source Path: hdlcoder_QPSKTxRx_RFSoC/QPSK/QPSK Rx/Frequency and Time Synchronizer/Packet Controller/sample discard 
-- controlle
-- Hierarchy Level: 4
-- Model version: 9.4
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY QPSK_src_sample_discard_controller IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb_1_4_0                         :   IN    std_logic;
        dataIn_re                         :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
        dataIn_im                         :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
        validIn                           :   IN    std_logic;
        startIn                           :   IN    std_logic;
        endIn                             :   IN    std_logic;
        dataOut_re                        :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
        dataOut_im                        :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
        startOut                          :   OUT   std_logic;
        endOut                            :   OUT   std_logic;
        validOut                          :   OUT   std_logic
        );
END QPSK_src_sample_discard_controller;


ARCHITECTURE rtl OF QPSK_src_sample_discard_controller IS

  -- Signals
  SIGNAL stateControl_1                   : std_logic;
  SIGNAL stateControl_2                   : std_logic;
  SIGNAL enb_1_4_0_gated                  : std_logic;
  SIGNAL dataIn_re_signed                 : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL dataIn_im_signed                 : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL validIn_1                        : std_logic;
  SIGNAL startIn_1                        : std_logic;
  SIGNAL endIn_1                          : std_logic;
  SIGNAL dataOut_re_1                     : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL dataOut_im_1                     : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL startOut_1                       : std_logic;
  SIGNAL endOut_1                         : std_logic;
  SIGNAL validOut_1                       : std_logic;
  SIGNAL active                           : std_logic;
  SIGNAL dataOutReg_re                    : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL dataOutReg_im                    : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL validOutReg                      : std_logic;
  SIGNAL startOutReg                      : std_logic;
  SIGNAL endOutReg                        : std_logic;
  SIGNAL active_next                      : std_logic;
  SIGNAL dataOutReg_next_re               : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL dataOutReg_next_im               : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL validOutReg_next                 : std_logic;
  SIGNAL startOutReg_next                 : std_logic;
  SIGNAL endOutReg_next                   : std_logic;
  SIGNAL dataOut_re_tmp                   : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL dataOut_im_tmp                   : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL dataOut_last_value_re            : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL dataOut_last_value_im            : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL startOut_2                       : std_logic;
  SIGNAL startOut_last_value              : std_logic;
  SIGNAL endOut_2                         : std_logic;
  SIGNAL endOut_last_value                : std_logic;
  SIGNAL validOut_2                       : std_logic;
  SIGNAL validOut_last_value              : std_logic;

BEGIN
  stateControl_1 <= '1';

  delayMatch3_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        stateControl_2 <= '0';
      ELSIF enb_1_4_0 = '1' THEN
        stateControl_2 <= stateControl_1;
      END IF;
    END IF;
  END PROCESS delayMatch3_process;


  enb_1_4_0_gated <= stateControl_2 AND enb_1_4_0;

  dataIn_re_signed <= signed(dataIn_re);

  dataIn_im_signed <= signed(dataIn_im);

  delayMatch_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        validIn_1 <= '0';
      ELSIF enb_1_4_0 = '1' THEN
        validIn_1 <= validIn;
      END IF;
    END IF;
  END PROCESS delayMatch_process;


  delayMatch1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        startIn_1 <= '0';
      ELSIF enb_1_4_0 = '1' THEN
        startIn_1 <= startIn;
      END IF;
    END IF;
  END PROCESS delayMatch1_process;


  delayMatch2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        endIn_1 <= '0';
      ELSIF enb_1_4_0 = '1' THEN
        endIn_1 <= endIn;
      END IF;
    END IF;
  END PROCESS delayMatch2_process;


  sample_discard_controller_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        active <= '0';
        dataOutReg_re <= to_signed(16#0000#, 16);
        dataOutReg_im <= to_signed(16#0000#, 16);
        validOutReg <= '0';
        startOutReg <= '0';
        endOutReg <= '0';
      ELSIF enb_1_4_0_gated = '1' THEN
        active <= active_next;
        dataOutReg_re <= dataOutReg_next_re;
        dataOutReg_im <= dataOutReg_next_im;
        validOutReg <= validOutReg_next;
        startOutReg <= startOutReg_next;
        endOutReg <= endOutReg_next;
      END IF;
    END IF;
  END PROCESS sample_discard_controller_process;

  sample_discard_controller_output : PROCESS (active, dataIn_im_signed, dataIn_re_signed, dataOutReg_im, dataOutReg_re,
       endIn_1, endOutReg, startIn_1, startOutReg, validIn_1, validOutReg)
    VARIABLE active_temp : std_logic;
  BEGIN
    active_temp := active;
    --MATLAB Function 'QPSK/QPSK Rx/Frequency and Time Synchronizer/Packet Controller/sample discard controller'
    startOutReg_next <= startIn_1;
    endOutReg_next <= endIn_1;
    IF startIn_1 = '1' THEN 
      active_temp := '1';
    END IF;
    IF active_temp = '1' THEN 
      dataOutReg_next_re <= dataIn_re_signed;
      dataOutReg_next_im <= dataIn_im_signed;
      validOutReg_next <= validIn_1;
    ELSE 
      dataOutReg_next_re <= to_signed(16#0000#, 16);
      dataOutReg_next_im <= to_signed(16#0000#, 16);
      validOutReg_next <= '0';
    END IF;
    IF endIn_1 = '1' THEN 
      IF active_temp = '1' THEN 
        endOutReg_next <= '1';
      ELSE 
        endOutReg_next <= '0';
      END IF;
      active_temp := '0';
    END IF;
    dataOut_re_1 <= dataOutReg_re;
    dataOut_im_1 <= dataOutReg_im;
    startOut_1 <= startOutReg;
    endOut_1 <= endOutReg;
    validOut_1 <= validOutReg;
    active_next <= active_temp;
  END PROCESS sample_discard_controller_output;


  out0_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        dataOut_last_value_re <= to_signed(16#0000#, 16);
        dataOut_last_value_im <= to_signed(16#0000#, 16);
      ELSIF enb_1_4_0_gated = '1' THEN
        dataOut_last_value_re <= dataOut_re_tmp;
        dataOut_last_value_im <= dataOut_im_tmp;
      END IF;
    END IF;
  END PROCESS out0_bypass_process;


  
  dataOut_re_tmp <= dataOut_last_value_re WHEN stateControl_2 = '0' ELSE
      dataOut_re_1;
  
  dataOut_im_tmp <= dataOut_last_value_im WHEN stateControl_2 = '0' ELSE
      dataOut_im_1;

  dataOut_re <= std_logic_vector(dataOut_re_tmp);

  dataOut_im <= std_logic_vector(dataOut_im_tmp);

  out1_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        startOut_last_value <= '0';
      ELSIF enb_1_4_0_gated = '1' THEN
        startOut_last_value <= startOut_2;
      END IF;
    END IF;
  END PROCESS out1_bypass_process;


  
  startOut_2 <= startOut_last_value WHEN stateControl_2 = '0' ELSE
      startOut_1;

  out2_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        endOut_last_value <= '0';
      ELSIF enb_1_4_0_gated = '1' THEN
        endOut_last_value <= endOut_2;
      END IF;
    END IF;
  END PROCESS out2_bypass_process;


  
  endOut_2 <= endOut_last_value WHEN stateControl_2 = '0' ELSE
      endOut_1;

  out3_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        validOut_last_value <= '0';
      ELSIF enb_1_4_0_gated = '1' THEN
        validOut_last_value <= validOut_2;
      END IF;
    END IF;
  END PROCESS out3_bypass_process;


  
  validOut_2 <= validOut_last_value WHEN stateControl_2 = '0' ELSE
      validOut_1;

  startOut <= startOut_2;

  endOut <= endOut_2;

  validOut <= validOut_2;

END rtl;

