-- -------------------------------------------------------------
-- 
-- File Name: C:\QPSK\hdl_prj_zcu111\hdlsrc\hdlcoder_QPSKTxRx_RFSoC\QPSK_src_MATLAB_Function_block.vhd
-- Created: 2025-09-17 13:27:53
-- 
-- Generated by MATLAB 25.1, HDL Coder 25.1, and Simulink 25.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: QPSK_src_MATLAB_Function_block
-- Source Path: hdlcoder_QPSKTxRx_RFSoC/QPSK/To DMA/Sync Controller/MATLAB Function
-- Hierarchy Level: 3
-- Model version: 9.4
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY QPSK_src_MATLAB_Function_block IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        mode_in                           :   IN    std_logic_vector(1 DOWNTO 0);  -- ufix2
        length_in                         :   IN    std_logic_vector(31 DOWNTO 0);  -- uint32
        last_in                           :   IN    std_logic;
        freerun_enable                    :   OUT   std_logic;
        freerun_enable_update             :   OUT   std_logic;
        trigger_enable                    :   OUT   std_logic;
        length_out                        :   OUT   std_logic_vector(31 DOWNTO 0)  -- uint32
        );
END QPSK_src_MATLAB_Function_block;


ARCHITECTURE rtl OF QPSK_src_MATLAB_Function_block IS

  -- Signals
  SIGNAL mode_in_unsigned                 : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL length_in_unsigned               : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL length_out_tmp                   : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL next_state                       : std_logic;  -- ufix1
  SIGNAL trigger_enable_reg               : std_logic;
  SIGNAL length_reg                       : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL mode_reg                         : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL next_state_next                  : std_logic;  -- ufix1
  SIGNAL trigger_enable_reg_next          : std_logic;
  SIGNAL length_reg_next                  : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL mode_reg_next                    : unsigned(1 DOWNTO 0);  -- ufix2

BEGIN
  mode_in_unsigned <= unsigned(mode_in);

  length_in_unsigned <= unsigned(length_in);

  MATLAB_Function_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        next_state <= '0';
        mode_reg <= to_unsigned(16#0#, 2);
        trigger_enable_reg <= '0';
        length_reg <= to_unsigned(16#00000000#, 32);
      ELSIF enb = '1' THEN
        next_state <= next_state_next;
        trigger_enable_reg <= trigger_enable_reg_next;
        length_reg <= length_reg_next;
        mode_reg <= mode_reg_next;
      END IF;
    END IF;
  END PROCESS MATLAB_Function_process;

  MATLAB_Function_output : PROCESS (last_in, length_in_unsigned, length_reg, mode_in_unsigned, mode_reg,
       next_state, trigger_enable_reg)
  BEGIN
    next_state_next <= next_state;
    trigger_enable_reg_next <= trigger_enable_reg;
    length_reg_next <= length_reg;
    mode_reg_next <= mode_reg;
    --MATLAB Function 'QPSK/To DMA/Sync Controller/MATLAB Function'
    -- State machine to synchronize switching between capture modes and ensure
    -- switch does not happen in the middle of a frame
    freerun_enable <= '0';
    freerun_enable_update <= '0';
    CASE next_state IS
      WHEN '0' =>
        IF mode_in_unsigned /= to_unsigned(16#0#, 2) THEN 
          IF mode_in_unsigned = to_unsigned(16#1#, 2) THEN 
            freerun_enable <= '1';
          ELSE 
            freerun_enable <= '0';
          END IF;
          freerun_enable_update <= '1';
          IF mode_in_unsigned = to_unsigned(16#2#, 2) THEN 
            trigger_enable_reg_next <= '1';
          ELSE 
            trigger_enable_reg_next <= '0';
          END IF;
          mode_reg_next <= mode_in_unsigned;
          length_reg_next <= length_in_unsigned;
          next_state_next <= '1';
        END IF;
      WHEN '1' =>
        IF last_in = '1' AND (mode_in_unsigned /= mode_reg) THEN 
          next_state_next <= '0';
          freerun_enable_update <= '1';
          trigger_enable_reg_next <= '0';
        END IF;
      WHEN OTHERS => 
        NULL;
    END CASE;
    trigger_enable <= trigger_enable_reg;
    length_out_tmp <= length_reg;
  END PROCESS MATLAB_Function_output;


  length_out <= std_logic_vector(length_out_tmp);

END rtl;

