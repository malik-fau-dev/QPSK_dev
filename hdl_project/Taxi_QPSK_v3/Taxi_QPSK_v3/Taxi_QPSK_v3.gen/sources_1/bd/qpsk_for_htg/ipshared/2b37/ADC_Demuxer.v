// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\ADCDeMuxerPrj\ADC_Demuxer.v
// Created: 2019-06-23 00:48:19
// 
// Generated by MATLAB 9.6 and HDL Coder 3.14
// 
// 
// -- -------------------------------------------------------------
// -- Rate and Clocking Details
// -- -------------------------------------------------------------
// Model base rate: 0.2
// Target subsystem base rate: 0.2
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: ADC_Demuxer
// Source Path: ADCDeMuxerPrj/ADC_Demuxer
// Hierarchy Level: 0
// Format samples to be read by DUT entering from the ADC  
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module ADC_Demuxer
          #(
          parameter IQMODE = 1,
          parameter SAMPLESPERCLOCK = 4,
          parameter ISGEN3 = 1         
          )
          (ADC_In,  //Real only for >8 samples per clock
           ValidIn, //Real only for >8 samples per clock
           ADC_Out_0, //Real only for >8 samples per clock
           ADC_Out_1, //Real only for >8 samples per clock
           ValidOut,  //Real only for >8 samples per clock
           I_In,   // Input stream for I from RFIP (Gen1)
           Q_In,   // Input stream for Q from RFIP (Gen1)
           I_Valid_In,  // To be used for both RFIP->DUT (Gen1)
           Q_Valid_In,  // To be used for both RFIP->DUT (Gen1)         
           IQ_In,  // Enabled if using IQ interleaved - input from RFIP (Gen3 only)
           IQ_Valid_In, // Enabled if using IQ (Gen3 only)
           I_Out,   // I channel to DUT (For all gen)
           Q_Out,   // Q channel to DUT (For all gen)
           IQ_Valid_Out); // Enabled if using IQ interleaved

  input   signed [(SAMPLESPERCLOCK*16-1):0] ADC_In;  // sfix128 - from RFDC - real only
  input   signed [(SAMPLESPERCLOCK*16-1):0] I_In;  // sfix128 - from RFDC - gen1 IQ input
  input   signed [(SAMPLESPERCLOCK*16-1):0] Q_In;  // sfix128 - from RFDC - gen1 IQ input
  input   signed [ (SAMPLESPERCLOCK*2*16-1):0 ] IQ_In;   // gen3 IQ input

  input   ValidIn; //input REAL valid
  input   I_Valid_In;  // I valid
  input   Q_Valid_In;  // Q valid
  input   IQ_Valid_In; // IQ Valid in (Gen3)
  output  IQ_Valid_Out; // IQ Valid out (all)
  output  ValidOut; // output REAL valid

  output  signed [ ((SAMPLESPERCLOCK > 8) ? 127:(16*SAMPLESPERCLOCK-1)) :0] ADC_Out_0;  // REAL lower-bits to DUT. if >8 samples we occupy all 128-bits. If < 8 samples, we choose 16*samples per clock
  output  signed [ ((SAMPLESPERCLOCK > 8) ? (16*(SAMPLESPERCLOCK-8)-1):0):0] ADC_Out_1;  // REAL upper-bits to DUT. Only use if >8 samples per clock. Remaining upper bits placed here

  output  signed [(SAMPLESPERCLOCK*16-1):0] I_Out;  // I lower-bits to DUT
  output  signed [(SAMPLESPERCLOCK*16-1):0] Q_Out;  // Q lower-bits to DUT
  
  genvar n; 
  if (IQMODE==0)
    // for REAL only - accomdates >8 samples per clock as well
    begin
      for (n=0;n<SAMPLESPERCLOCK;n=n+1) begin: in_loop
        if (n<8)
          assign ADC_Out_0[((n+1)*16-1):(n*16)] = {ADC_In[((n+1)*16-1):(n*16)]};  // lower bit
        else
          assign ADC_Out_1[((n-8+1)*16-1):((n-8)*16)] = {ADC_In[((n+1)*16-1):(n*16)]}; // upper bit
      end
      assign ValidOut = ValidIn; // for REAL Valid
    end       
  else if (  IQMODE==1 && ISGEN3 == 1 )
    // de-interleave incoming IQ stream - Gen3 only
    begin
      for (n=0; n<SAMPLESPERCLOCK; n=n+1) begin: in_loop
        assign I_Out[((n+1)*16-1):(n*16)] = {IQ_In[((2*n+1)*16-1):(2*n*16)]};
        assign Q_Out[((n+1)*16-1):(n*16)] = {IQ_In[((2*n+1)*16-1+16):(2*n*16+16)]};
      end     
      assign IQ_Valid_Out = IQ_Valid_In ; // IQ Valid;
    end
  else
    // For IQ Gen1
    begin
      assign I_Out = I_In;    
      assign Q_Out = Q_In;
      assign IQ_Valid_Out = I_Valid_In & Q_Valid_In; // IQ Valid;
    end

endmodule  // ADC_Demuxer

